"""
interactive_repy_console.r2py --- as the name says!

Interactive Repy Console is meant to be uploaded to a Seattle VM and 
run there. It will listen on a TCP port for an incoming connection 
from your Telnet client, netcat, or similar, and then provide a 
RepyV2 Read-Evaluate-Print Loop (REPL). 
This eases experimentation, as it shortcuts `seash` for the most part: 
You can work interactively, see the VM log as it is written to, get 
immediate feedback if there are any errors in your code, etc. 
All of Repy will work as expected; you might upload and then import 
libraries as well; calling the `help()` function will list a few 
other things it provides.

(Note: There is a Python version of Interactive Repy Console too. 
You would run that on your local machine.)

Usage:
In seash,
user@group !> start dylink.r2py interactive_repy_console.r2py LISTENPORT

   or
user@group !> start dylink.r2py interactive_repy_console.r2py

Using the first form, Interactive Repy Console will try to bind to 
LISTENPORT and use it to receive incoming connections. Using the 
second form, it will choose a port automatically.
Either way, the port is logged in the VM log so you know how to 
contact it.

You would then go and upload your own code using seash, and start it 
inside Interactive Repy Console to see if it performs as expected. 
When in doubt, call the help() function on the prompt.
"""

# Override a few RepyV2 API calls
real_exitall = exitall
real_log = log

def exitall():
  pass


def log(*args):
  """Print the given arguments to the VM log. 
  XXX In a later implementation, send them to the Telnet client too."""
  string_to_print = ""
  for arg in args:
    string_to_print += str(arg) + " "
  # XXX send_to_telnet_client_now(string_to_print)
  # Print to the VM log
  real_log(string_to_print)



def quit(message="Quitting Interactive Repy Console (and any thread that "
        "might be running still).\n"):
  if message:
    log(message)
  real_exitall()



def help():
  """List and explain the handy functions we implement."""
  log("""In addition to the RepyV2 API and all library calls you imported, 
you may call these builtin functions during your session:

help()      -- displays this text
cat(file)   -- prints the contents of file to the screen (and the VM log)
module = dy_import_module(modulefilename)
            -- use this instead of Python's `import modulename as module`
dy_import_module_symbols(modulefilename)
            -- use this instead of Python's `from modulename import *`
quit(message=...)
            -- quits Interactive Repy Console and prints an overrideable message
start(file) -- imports file and calls into `if callfunc=="initialize": ...`,
               as seash's `start` command would do

Note: The following Repy functions been overwritten by Interactive Repy Console:
exitall()   -- will not perform any function
log(*args)  -- will both print to the VM log and this network connection

You can always get the original functions back, they are stored as "real_*". 
In case anything goes wrong because your code hangs etc., just use seash 
to stop and then restart the VM.

""")



def create_server(remote_ip, remote_port, user_connection):
  """This will return an argument-less function for `createthread`. 
  The arguments given will be available to the function we return 
  via a closure."""
  def server():
    log("Incoming client on", remote_ip, "port", remote_port, "\n")
    # XXX Actually handle the client now!

  return server



if callfunc == "initialize":
  # Initialize the listening socket, respecting the optional callarg.
  try:
    listen_port = int(callargs[0])
  except ValueError:
    # An arg was given, but it is not parseable as int.
    log("""Usage: interactive_repy_console.r2py [LISTEN_PORT]
where LISTEN_PORT is an optional port I should listen on. When omitted, 
an available TCP port is chosen automatically, and announced in the VM log.
""")
    exitall()
  except IndexError:
    # No port arg was given. Try to find a port ourselves!
    for listen_port in getresources()[0]["connport"]:
      try:
        listen_socket = listenforconnection(getmyip(), listen_port)
        log("Listening on", getmyip(), "port", listen_port, "\n")
        break
      except (AlreadyListeningError, DuplicateTupleError, 
          RepyArgumentError, ResourceForbiddenError, AddressBindingError):
        # These are all indicative that we can't listen here. Keep trying!
        pass
    else:
      # If we end up here, none of the ports worked. Quit!
      quit("Sorry, none of the ports I tried would work. I'm giving up.\n")

  # Down here, all is well. We have a listening socket for the user.
  # Let's see when they connect in.
  while True:
    try:
      (remote_ip, remote_port, user_connection) = listen_socket.getconnection()
      server = create_server(remote_ip, remote_port, user_connection)
      createthread(server)
    except SocketWouldBlockError:
      # No incoming connection this time. Check again later.
      sleep(0.1)
    except:
      # We can't do anything sensible with other errors. Let's 
      # have Repy print a stacktrace.
      raise

