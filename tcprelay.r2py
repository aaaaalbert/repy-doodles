"""
tcprelay.r2py --- a simplistic TCP relay

USAGE as a client-side library:

* Determine the IP address and control port of the TCP relay to use
* Set up a relayed listen socket by calling `relayedlisten` with
  appropriate arguments
* Proceed to use this socket like a normal RepyV2 TCPServerSocket,
  i.e. call its `getconnection` method to receive incoming (relayed)
  connections on your forwarded relay port, and `close` it when you
  are done listening.
(Hint: If the relay immediately drops your connection, try a different
control port. The current one might be taken by a client from the same
public IP address as yours.)


USAGE for running a TCP relay:

To start a TCP relay on your vessel, no arguments are needed:
  tcprelay.r2py

(By default, the first half of the vessel's connports will be
used as control ports. See the vessel log for details.)


USAGE as a command-line client:

To use a TCP relay for listening on behalf of LOCAL_PORT, use
``client'' mode and specify which RELAY_IP_ADDRESS and RELAY_PORT
to use:
  tcprelay.r2py client LOCAL_PORT RELAY_IP_ADDRESS RELAY_PORT

(This is similar to `ssh`'s -L option. Incoming forwarded
connections are then made available on the local port, to
which you can connect using `netcat` or similar, e.g.
`nc 127.0.0.1 LOCAL_PORT`)


-----

# Design Overview

The TCP relay has two groups of server ports:
* Some for incoming control connections from clients,
* Some for incoming userplane connections from remote stations.

To set up relaying, a client
* Connects to a control port on the relay,
* Receives the relayed listening port supplied by the relay, and
* Sets up a secondary connection to the control port which will be
  used to forward data as soon as an incoming remote host connects.

The client keeps the control connection alive as long as it uses the relay.

To receive incoming connections on the relayed port, the client
receives data from the primary control connection.
* If an incoming remote host waits,
  - the relay sends the remote host's IP address and port, and
  - internally connects the client's secondary connection to the
    incoming remote host connection to forward data between them.
  - The client establishes a new secondary connection in preparation
    for the next incoming remote host connection.
* If there is no incoming host, there is no data on the relay-to-client
  connection.

Connection closes from the client or the remote host cause the
forwarded connection to be closed by the relay as well.
Closing the primary control connection may close all currently
forwarded connections of this client.


# Commentary

Requiring a primary and (possibly multiple) secondary connection(s)
from a client is motivated by previous experience with other schemes.
* TCPRelayAffix used an elaborate application-layer scheme to signal
  new incoming messages on the (single) control connection. This
  required constant and frequent polling, so as to not miss an
  incoming connection with short timeout. Also, setting up what
  I call the "secondary" connection now isn't always guaranteed
  to succeed in time, so this was a big race.
* The previous implementation of this TCP relay also used a single
  control connection, and turned calls to the relayed socket's
  `getconnection` method into new connections to the control port.
  If no new remote host connection was available, the relay just
  closed the new secondary connection.  This exhausts available
  ports quickly, as the operating system's network stack keeps state
  for closed sockets around for a while.
* Therefore, we set up a primary control connection and prepare a
  secondary connection right away, and require a new secondary
  connection to be set up as soon as the first one is used.

To demultiplex different clients from the same public IP, we hope that
* Each client likely uses a different control port (or relay).
* Even if a second client on that public IP and relay tries an
  already-used control port, the probability is low that this
  happens exactly between an existing secondary connection getting
  used newly, and a new secondary getting set up.
* The relay should probably drop an unexpected additional secondary
  connection from a seemingly-known client.
(If collisions become a problem, we can try to enforce collision-free port
usage by clients on the same public IP, or add application-layer tokens.)

Notes about port usage:
Clients that share a pubic IP must use different control ports on
the same relay. However, clients from different public IPs may share
the control port. This may skew the proportion of control to relayed
ports to our favor (i.e. yield more relayed ports).
"""
# Buffer at most this many bytes for relaying between hosts
MAX_BUFFER_LEN = 1400

# These are control messages from the relay to the client on
# the control connection.
YOUR_RELAYED_PORT_IS = "Your relayed port is "
NEW_REMOTE_STATION = "New remote station "


def relayedlisten(relayip, relayport, localip, localport):
  """
  Contact the given relay, and return the relayed port and an
  object that behaves like a Repy TCP server socket with
  `getconnection` and `close`.
  This function is similar to RepyV2's `listenforconnection`, but
  it takes more parameters and may raise additional exceptions
  (which arise in `openconnection` towards the relay).
  """
  relayed_listen_socket = RelayedTCPListenSocket(relayip, relayport, localip, localport)
  return relayed_listen_socket.relayed_listen_port, relayed_listen_socket



class RelayedTCPListenSocket():
  """Implement a socket-like class that behaves mostly like a RepyV2
  TCPServerSocket. Behind the scenes, contact the TCP relay given at
  instantion time, and handle primary and secondary control connections
  as required to return sockets connecting to remote hosts when
  `getconnection` is called.
  """
  def __init__(self, relayip, relayport, localip, localport):
    """Initialize our control connections to the TCP relay."""
    self.relayip = relayip
    self.relayport = relayport
    self.localip = localip
    self.control_socket = openconnection(relayip, relayport, localip, localport, 5)
    self.secondary_connection = None

    started = getruntime()
    while getruntime()-started < 5:
      try:
        port_info = self.control_socket.recv(100)
        self.relayed_listen_port = int(port_info[len(YOUR_RELAYED_PORT_IS):-1])
        break
      except SocketWouldBlockError:
        sleep(0.1)
    else:
      # We never received info about our relayed port from the relay.
      # Abort this control connection.
      self.close()
      raise TCPServerSocketInvalidError("Did not receive a relayed port.")

    self.secondary_connection = self._get_new_secondary_control_connection()


  def _get_new_secondary_control_connection(self):
    """Helper function to set up a new secondary control connection."""
    for source_port in list(getresources()[0]["connport"]):
      try:
        return openconnection(self.relayip, self.relayport, self.localip,
            source_port, 5)
      except (AlreadyListeningError, DuplicateTupleError, RepyArgumentError, TimeoutError, CleanupInProgressError):
        # Retry using a different port
        continue
      except (ConnectionRefusedError, InternetConnectivityError), e:
        # The relay and our relayed socket have become stale. This is fatal.
        raise TCPServerSocketInvalidError("No connection to relay " +
            self.relayip + " port " + str(self.relayport) + ", error '" +
            repr(e) + "'.")
    else:
      raise TCPServerSocketInvalidError("No free source ports for secondary control connection to TCP relay" +  self.relayip + " port " + str(self.relayport))


  def close(self):
    """Stop relayed listening using this control connection."""
    self.control_socket.close()


  def getconnection(self):
    """Receive information about an incoming remote host connection (if
    any) from the primary control connection. Set up a new secondary
    control connection in preparation for the next incoming host. Return
    the current remote host's address and port, and the current secondary
    connection as a socket.
    """
    try:
      who_is_it = self.control_socket.recv(100)
    except SocketWouldBlockError:
      # No new relayed connection!
      raise
    except (SocketClosedRemote, SocketClosedLocal), e:
      # If the control socket has been closed, we can't use the relay anymore.
      raise TCPServerSocketInvalidError("Lost connection to the TCP relay, " +
          "error '" + repr(e) + "'.")
    else:
      remote_ip, remote_port = who_is_it[len(NEW_REMOTE_STATION):-1].split()
      # Use the current secondary connection for this relayed remote host,
      # and provide a new secondary for the next incoming connection.
      relayed_socket = self.secondary_connection
      self.secondary_connection = self._get_new_secondary_control_connection()
    return remote_ip, remote_port, relayed_socket





def do_forward(client_ip, client_port, client_socket, remote_ip,
    remote_port, remote_socket, client_buffer, remote_buffer, is_alive):
  # The interesting logic down here works like this:
  # If the connection is still alive, receive as much as we can possibly
  # forward into the buffer. Then, regardless of liveliness, send from
  # the buffer into the socket. Do this for both directions (from/to
  # client/remote station).
  # If we think the connection isn't live anymore, stop receiving, but
  # still try to clear out our buffers.
  if is_alive:
    remote_buffer_space = MAX_BUFFER_LEN - len(remote_buffer)
    if remote_buffer_space > 0:
      try:
        remote_buffer += client_socket.recv(remote_buffer_space)
      except SocketWouldBlockError:
        pass
      except (SocketClosedLocal, SocketClosedRemote):
        is_alive = False
        client_buffer = ""

  try:
    bytes_sent = remote_socket.send(remote_buffer)
    remote_buffer = remote_buffer[bytes_sent:]
  except SocketWouldBlockError:
    pass
  except (SocketClosedLocal, SocketClosedRemote):
    is_alive = False
    remote_buffer = ""

  if is_alive:
    client_buffer_space = MAX_BUFFER_LEN - len(client_buffer)
    if client_buffer_space > 0:
      try:
        client_buffer += remote_socket.recv(client_buffer_space)
      except SocketWouldBlockError:
        pass
      except (SocketClosedLocal, SocketClosedRemote):
        is_alive = False
        remote_buffer = ""

  try:
    bytes_sent = client_socket.send(client_buffer)
    client_buffer = client_buffer[bytes_sent:]
  except SocketWouldBlockError:
    pass
  except (SocketClosedLocal, SocketClosedRemote):
    is_alive = False
    client_buffer = ""

  return client_buffer, remote_buffer, is_alive





def run_server():
  log("Starting TCP relay on IP address", getmyip(), "\n")
  # Ratio of control ports among total connports. Note `float`.
  CONTROL_PORT_RATIO = float(1)/2
  connports = list(getresources()[0]["connport"])
  connports.sort()
  control_port_count = int(CONTROL_PORT_RATIO * len(connports))
  control_ports = connports[:control_port_count]
  relay_ports = connports[control_port_count:]
  log("Control ports:", control_ports, "\nRelay ports:", relay_ports, "\n")

  # These store the listening sockets for incoming connections.
  # relay_sockets is indexed by (client_ip, control_port).
  control_sockets = []
  relay_sockets = {}

  for port in control_ports:
    try:
      control_sockets.append((port, listenforconnection(getmyip(), port)))
    except Exception, e:
      log("Error attempting to listen on port " + str(port) + ": " + repr(e))
  if len(control_sockets)==0:
    log("Failed to listen on any of the control ports. Exiting.")
    exitall()

  # This stores all of our connections.
  # "control_new" stores the control port and client details.
  # All sub-dicts are indexed by (client_ip, control_port).
  # "control_partial" has the per-client control socket object for
  # clients with no unused secondary connection.
  # "control_full" stores clients with a primary (i.e. control) and
  # secondary (i.e. prepared forwarding) connection.
  # "relay_new" stores a per-client list of IP, port, socket for incoming
  # remote station connections.
  # "relay_active" stores a per-client list of tuples that contain all
  # connection details, socket objects, buffers, and status for the
  # client-to-relay and relay-to-remote-station connections.
  connections = {
      "control_new": [],     # Accepted incoming client connections
      "control_partial": {}, # Primary-only client connections
      "control_full": {},    # Client connections with prepared secondary conn
      "relay_new": {},       # Accepted incoming relay connections
      "relay_active": {},    # Existing relay connections
      }


  def handle_control_connections():
    # Check all control sockets for new connections
    for control_port, control_socket in control_sockets:
      try:
        client_ip, client_port, client_socket = control_socket.getconnection()
        connections["control_new"].append((control_port, client_ip,
            client_port, client_socket))
      except SocketWouldBlockError:
        pass

    # Handle all new control connections, depending on the client's status.

    for control_port, client_ip, client_port, client_socket in connections["control_new"]:
      client_id = (client_ip, control_port)
      # Check if we know this client IP address.
      if client_id in connections["control_full"].keys():
        # Nothing to do for a client with prepared secondary connection!
        client_socket.close()
        continue

      if client_id in connections["control_partial"].keys():
        # This is a partially-connected client's secondary connection.
        # Move the client plus new conn details to control_full.
        # XXX This is where multiple clients behind the same NAT gateway may
        # XXX clash. The other client would get to provide the secondary
        # XXX connection, and we may leak incoming remote connections.
        control_connection = connections["control_partial"][client_id]
        connections["control_full"][client_id] = (control_connection,
            client_ip, client_port, client_socket)
        del connections["control_partial"][client_id]
        continue

      # If we end up here, we don't know the client yet.
      # Set up a new forward for them.
      for relay_port in relay_ports:
        try:
          relay_socket = listenforconnection(getmyip(), relay_port)
          client_socket.send(YOUR_RELAYED_PORT_IS + str(relay_port) + "\n")
        except (AlreadyListeningError, SocketWouldBlockError):
          continue
        except (SocketClosedRemote), e:
          log("Error notifying", client_id, "about relay port", relay_port,
              repr(e), "\n")
        else:
          # Only if this worked out, commit this new client to the
          # relevant interal data structures.
          relay_sockets[client_id] = relay_socket
          connections["control_partial"][client_id] = client_socket
          connections["relay_new"][client_id] = []
          connections["relay_active"][client_id] = []
          break
      else:
        try:
          # Be verbose, tell them what went wrong
          client_socket.send("No free relay port, sorry!")
        except:
          pass
        client_socket.close()

    # Every previously "partial" client is now a "full" client.
    # Every previously new client is now a "partial" client with a relayed
    # port now, or got signaled that we can't forward for them.
    connections["control_new"] = []



  def clean_up_connected_clients():
    # Collect all client control sockets
    client_control_sockets = []
    for client_id, full_conn_details in connections["control_full"].items():
      control_connection, ip, port, secondary_conn = full_conn_details
      client_control_sockets.append((client_id, control_connection))
    for client_id, control_connection in connections["control_partial"].items():
      client_control_sockets.append((client_id, control_connection))

    # Test every socket for liveliness
    for client_id, socket in client_control_sockets:
      try:
        try:
          # Ignore whatever they send
          socket.recv(1400)
        except SocketWouldBlockError:
          pass
        try:
          # Send nothing, just as a liveliness check
          socket.send("")
        except SocketWouldBlockError:
          # Send buffer full? That's interesting!
          pass
      except (SocketClosedLocal, SocketClosedRemote):
        # The control connection has gone down. Remove this client.
        for conndict in (connections["control_full"], connections["control_partial"]):
          try:
            del conndict[client_id]
          except KeyError:
            pass
          # XXX Also close relayed connections?



  def handle_relayed_connections():
    # Check all relay sockets for new connections.
    # Store new relay connections for clients; connect with prepared
    # secondary connections later on.
    for client_id, relay_socket in relay_sockets.items():
      # Don't pick up incoming connections if the client hasn't
      # prepared a secondary port yet.
      if client_id not in connections["control_full"].keys():
        continue
      try:
        connection_details = relay_socket.getconnection()
        connections["relay_new"][client_id].append(connection_details)
      except SocketWouldBlockError:
        pass


    for client_id, remotes_list in connections["relay_new"].items():
      if len(remotes_list)>0:
        remote_ip, remote_port, remote_socket = remotes_list.pop(0)
        control_socket, _, _, client_socket = connections["control_full"][client_id]
        try:
          control_socket.send(NEW_REMOTE_STATION +
              remote_ip + " " + str(remote_port) + "\n")
        except (SocketClosedRemote, SocketClosedLocal), e:
          log("Error notifying", client_id, "about new remote", remote_ip,
              remote_port, repr(e), "\n")
          # XXX Remove this client!
        else:
          # Store the client socket, remote side details, two empty buffers,
          # and a liveliness flag for the actual forwarding.
          connections["relay_active"][client_id].append((client_socket,
              remote_ip, remote_port, remote_socket, "", "", True))
          # We have used up the client's prepared secondary connection.
          # Demote the client to "partial" state again.
          connections["control_partial"][client_id] = control_socket
          del connections["control_full"][client_id]

    # Forward all active connections
    for client_id, details_list in connections["relay_active"].items():
      (client_ip, client_port) = client_id
      new_details_list = []
      for (client_socket, remote_ip, remote_port, remote_socket,
          client_buffer, remote_buffer, is_alive) in details_list:
        # Do the actual forward, update buffers and liveliness
        client_buffer, remote_buffer, is_alive = do_forward(client_ip,
            client_port, client_socket, remote_ip, remote_port,
            remote_socket, client_buffer, remote_buffer, is_alive)
        # If either side has hung up and the data it sent has been forwarded,
        # close down the remaining connection.
        if not is_alive and len(client_buffer) == 0 and len(remote_buffer) == 0:
          remote_socket.close()
          client_socket.close()
        else:
          # We're still alive. Keep this connection.
          new_details_list.append((client_socket, remote_ip, remote_port,
              remote_socket, client_buffer, remote_buffer, is_alive))

      # Update details of this client's relayed connections
      connections["relay_active"][client_id] = new_details_list


  while True:
    handle_control_connections()
    clean_up_connected_clients()
    handle_relayed_connections()



if callfunc=="initialize":
  if len(callargs)==0:
    # Server mode!
    run_server()
  elif len(callargs)==4:
    # Client / local-forward mode
    log("Sorry, not yet implemented...\n")

